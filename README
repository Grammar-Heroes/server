This is the backend for Grammar Heroes.

Grammar Heroes is a game for anyone who wants to have fun constructing English sentences. 
The game is built for mobile, taking into account device accessibility within young Filipino students, especially our target demographic: Grades 4-6. 
The idea behind the game is to create something that is not only educational, but also, as cliche as it is, FUN. 
We understand that there exist various grammar apps that aid grammar correctness and learning. 
There is, for example, Duolingo, which is really popular, by the way. 
But it's not really the GENRE of application that you would recommend a 10 year old wanting to learn grammatically correct English.
Certainly, there are "gamification" elements here and there inside Duolingo.
However, data and empirical evidence suggest that, for our target demographic, it's not ideal. 

Hence, the vision behind Grammar Heroes is to foster an environment where kids can PLAY, EXPERIMENT, and FEEL SAFE GETTING SENTENCES WRONG.
We want the kids to see where they went wrong, why it is wrong, and therefore correct it. 

And if they're correct, deal damage to enemies. 
They can go on an adventure, quite literally because the levels branch out, you can forge your own path so to speak because there are various options. 
There isn't a single one path for you to finish the game, you can go from Level 1 to Level 2A or Level 2B for instance. 
It's totally up to you. We want kids to experience that feeling of freedom to choose where they want to go. 
They can customize their character. They can see where they rank among other players. They can see where they rank in a Knowledge Component. 
Like, let's say if you play the Subject-Verb Agreement level multiple times, you definitely would get to a higher rank because your KC keeps updating. 
And then you can view the Leaderboard for that KC and see yourself on top. And then you can move on to other KCs. 

The point here is that, you have your personality in the game, you can make mistakes, make grammar errors, silly grammar errors, and no one would know, except perhaps the database.
But it's more conducive to learn in an environment where nobody sees your mistakes except you.
But not only do you see it, you see exactly what's wrong with it. 
It's not announced in a class of 40 that you made this grammatical error. 
It's announced, and shown ever so gently, only, to you, the player.

Now, let's talk about how the game really works on the Frontend side. 
The game is built in Unity 6 using C#. While the game view is 2D, the game is actually made inside a 3D environment. 
We want that really cool way of making elements appear 2.5D. 
The light plays a huge role in creating an effective and engaging gaming experience. 
The assets are therefore 3D models made in Blender. 

So let's have a quick run down of how the game goes.

Imagine that you have downloaded the game on your phone. You then see the icon of the app, then you tap on it. 
The game loads its Login / Register screen. As someone who does not yet have an account, you click on Register. 
Upon clicking on the Register button, you are redirected in another page where you have three options to register an account. 
Either you create an Email/Password specifically for this game, register using an existing Google Account, or through Facebook.

This is the first problem in developing our game. (Note: Not anymore.)
We will use Firebase for Account Creation and Login. Then, we will use Neon.tech as our main database. 

Now, let's say you have successfully created an account. You are redirected to the Login Screen where you can login using your newly created account. 
So, you click on Login through Google, you choose the Google Account you just registered, and wow! You've successfully logged in to our game.

This is another problem. It's quite the same problem as our Register Problem. 
I don't see how the communication between Frontend, Firebase, Backend, and Neon.tech will work. 
That's the first thing we have to figure out. (Note: I figured this out.)

Okay, assuming that problem is now out of the way, and that you've successfully logged in. 
What's next? Well, you see the Home Screen! It's a simple Home Screen. You have a few buttons to click on. Play, Settings, Help, Leaderboards, etc.

Of course, our main focus here is the Play button. You click on "Play". You're now redirected to the Floor Screen. 
The game has three main floors, it's our way of saying, 
"This represents Grades 4, 5, and 6." 
Inside each Floor, say Floor 1, there are various Nodes, each node represents a level.
As said earlier: "There isn't a single one path for you to finish the game, you can go from Level 1 to Level 2A or Level 2B for instance." 
The Nodes don't just connect 1 : 1. Some nodes connect to two other nodes or sometimes 3 other nodes. 
And you are free to go to any of them! 
But of course, as you're someone who just downloaded the game and your account is newly created, you can only play at the first Level, for now. 
So, you're currently at [Floor 1 | Level 1]. 

But, wait, what happens in the backend when you click on the level?

Well, to understand what GET request we're doing upon choosing a level, we first have to see a sample gameplay:

1. You click on the Node.
2. You are given three Objectives:
	a: Defeat all the enemies!
	b: Create a sentence using all given cards!
	c: Create a sentence using two verbs!
3. You are then given a word set. [Word Set = ["Dog", "Across", "Street", "Run", "Runs", "The", "The"]]

[Note: A word set is a set of words, each word contained/represented in a card. A single word set is guaranteed to be able to form at least one complete sentence. A player gets 15 word sets in a single level.]

4. Now, the time starts ticking. You have N seconds to come up with a word! Frantically, you drag some cards from the bottom of the screen (they are there by default, kind of like "your deck of cards") onto the middle of the screen.

[Example: The dog runs across the street.]
[Example: The dog runs.] 
[Example: The dog run the street.] 

[Note: There are "Punctuation Cards" that are given by default.]

5. You then click the "Write" button to submit the sentence. [Sentence: "The dog run the street."]
6. The sentence is analyzed and evaluated and it was found that you provided a wrong sentence.
7. Some words you dragged onto the middle of the screen starts to get highlighted, or rather, the word "run" is now highlighted in "RED", that means, that word/s makes the sentence grammatically incorrect.
8. The clock, now only a few N seconds left, starts ticking again. You then removed that word by dragging it out of the middle of the screen, and onto your word set, at the bottom of the screen.
9. You dragged the "runs" card to replace "run". And then you hit "Write" again to submit your renewed sentence.
10. The sentence is again, analyzed and evaluated. It was found that you've got a correct sentence this time!
11. The damage of the sentence is also calculated. And you deal strong damage to the enemies! They're not yet dead though.
12. But wait, you haven't completed any objectives yet...
13. Since you're done with that word set, you are now given a new word set, and your time resets.

Word Set = [Bear, Sings, Dances, Front, In, A, Funny, And]
Time = N (we haven't decided how much time we'll give to each word set yet)

14. The clock starts ticking. Okay, you now look at the objectives and see that you have to use two verbs somehow. So, you look at your word set carefully and found that you have two verbs there! So, you drag some cards in the middle:

Sentence = A funny bear sings and dances in front.

15. You then hit "Write" to submit this sentence. The timer stops while the sentence is being analyzed. It was found that you submitted a grammatically correct sentence at first try! That's impressive!
16. You dealt a ton of damage to the enemies, successfully defeating 2/3 of them! Now, you only have one enemy left!
17. You start to observe the objectives, and you just completed two of them! You used all the words/cards in a given word set! And... you also used two verbs in one sentence! That's very amazing!
18. But, the jobs not done. You are now given another word set. The timer resets.

Word Set = [Prix, Their, Way, Drive, Through, Drives, The, Drivers, The, Dutch, Grand]

19. Oh no... this is a difficult word set. The timer starts ticking. You look at your objectives, and thought: "I just have to defeat this last enemy and I am done with this level." So, you locked in! You dragged some cards from your deck onto the middle:

Sentence = "The drivers drive their way through the Dutch Grand Prix."

20. You submitted the sentence, the timer stops, the sentence is being analyzed, you feel the tension, and then suddenly, insane damage was dealt to the last one of the enemies! The last enemy is defeated!!! Your objective is complete! You got 3 STARS!
21. The victory screen shows up. It's an evaluation of the level, the objectives you completed, and the best sentence (longest one) you came up with in this level.
22. Here's a note: The player is given two tries to submit a sentence, if both attempts fail, the enemies can attack them! The enemies don't really write their own sentences, they just attack you, and your health gets... lower. Which basically means... you lose if your health goes to zero, you win if the enemies' health goes to zero. But it's not just the enemy that you're fighting against, you're also against time, pressure, etc.
23. You click "Next Level", but really, you are redirected to the Node Selection screen because apparently, there isn't a single one "next level", you are presented with "Level 2A or Level 2B"! That's cool as heck, you can choose what you want!

Okay, so that's how it works in the frontend. Now, let's see how this plays out in the backend. To understand this, we have to go back to the very first step:

Step 1: You click on the Node. [Floor 1 | Level 1]

No requests to the backend is actually made here. But something important happens. You see, each level is assigned one Knowledge Component. Let's call that KC. For example, [Floor 1 | Level 1] has the KC, "Subject-Verb Agreement". This essentially decides what word sets will be available for such level. Because the "topic", so to speak, largely decides what words should be present in the word set, we have to match the Knowledge Component to the topic of the level to the word sets available for that level.
For instance, notice how the first word set available for you in this level is:

Word Set = ["Dog", "Across", "Street", "Run", "Runs", "The", "The"]

The word set is randomly chosen. However, the pool of word sets from which that word set is chosen is not random. So, how do we choose which word set will be given to the player?

In total, we have 20 Knowledge Components. These KCs are basically all the English Grammar concepts that we want the player to learn within the game. Each KC has 50 to 100 sentences each. That means, for the KC, "Subject-Verb Agreement", this word set: ["Dog", "Across", "Street", "Run", "Runs", "The", "The"], is just ONE among the 100 word sets that could have been given to the player AT RANDOM! But, as I said in the Frontend discussion: "A player gets 15 word sets in a single level."

Yes! That's right, the player gets 15 word sets per level. 15 RANDOM WORD SETS. But, there is something crucial that you have to understand: By the time the player reaches Floor 1 Level 4, there is no fixed KC for the level. Yes, you read that right, NO FIXED KNOWLEDGE COMPONENT IS ASSIGNED AT FLOOR 1 LEVEL 4 and some other levels throughout the game. That's weird? Let me tell you why we do this. Another very important and crucial feature of Grammar Heroes is it's capacity to adapt the topic to whatever the learner struggles with the most. Hence, Floor 1 Level 4 is what we call an "Adaptive Level". More on that later. (Note: We are using Bayesian Knowledge Tracing for the Adaptivity Feature)

Now, let's go back to the 15 random word sets. Only 11 of these word sets are about "Subject-Verb Agreement". The other 4 word sets are about KC2 and KC3. What is KC2 and KC3? Well, SVA is KC1. Each level corresponds to one KC. That means, Level 2A and Level 2B both correspond to KC2. Level 3A and Level 3B will both correspond to KC3. Level 4 is our adaptive level, which means it adaptively corresponds to either KC1, KC2, or KC3, depending on the player's performance. Now, each level (1, 2A, 2B, 3A, 3B) will have 15 word sets each. And 11 of these word sets will correspond to the KC they are representing. The remaining four will be divided in two (2 + 2). Each 2 will correspond to the KC the current level is not corresponding to. For example, since Level 1 corresponds to KC1, 11 cards from this level will correspond to KC1, 2 cards will correspond to KC2, and 2 cards for KC3, a total of 15 cards. The same pattern will repeat across the entire game. After every 3 KCs, there is an adaptive level, the KC to be represented by this adaptive level is simply one of the past 3 KCs which the player has the worst performance on.

I don't really understand how this affects BKT but they said it's how things are done. 

Now, let's really talk about the HTTP requests that will be made to the backend. First, let's get the user account stuff + authentication out of the way, that will be a totally separate topic. Let's really just go to the gameplay. 

--- FIRST HTTP REQUEST ---

The first request to the backend is made at this point:

5. You then click the "Write" button to submit the sentence. [Sentence: "The dog run the street."]

Yes, it is made when the user clicks "Write". The FRONTEND will send that sentence to the backend. It will come with a few stuff. First, the Knowledge Component corresponding the word set from which the sentence was created. Second, the level (level_id). I think those two are enough. The backend will process the sentence, evaluate whether it's grammatically correct or incorrect. Then, a few things will happen:

IF CORRECT: The backend will update the Knowledge Component accordingly, that's why we needed that KC alongside the sentence. Next, in our database, we have fixed objectives for each level_id. We will use the attached level_id to find those objectives, then, we will then check whether that objective was completed. The question now is: How would we check whether those objectives was accomplished? Some objectives are easier to check in the frontend. For example, if the objective was to submit a correct sentence within 30 seconds, since the frontend is the one who has access to the "time", then it's easier for them to check it. However, if the objective is "Use two verbs in a single sentence", such objective is easier to check in the backend because I have a grammar analyzer and I can just create a function specifically for this objective check. In other words, it will be a hybrid approach for objective checking. Some objectives will be evaluated in the backend, while some objectives will be evaluated in the frontend. The only similarity is that, both objectives will only be checked if the sentence was evaluated "correct". Also, to check an objective from the backend, we will use the level_id to find the objectives corresponding to it. Then, I will write specific functions for each objective, then run those. So.. perhaps a better way of doing this is, instead of level_id, just send the objective_id? Then we will use that id to find the function that will check whether that objective was completed? Since the objectives are all fixed, we can just assign "objective_id" to objectives that will be checked in the backend. Okay, so let's assume this works. In total this is what should happen:

The sentence was evaluated correct. We will update the KC. At the same time, we will return this response: isCorrect: bool, isAccomplished: List[bool] = [], wrongWords: List[string] = []

IF INCORRECT: It will do the same thing almost. It will update the Knowledge Component accordingly. However, it will not check for  the objectives anymore since it's a wrong sentence anyway. But, the backend will try to find out which words make the sentence wrong. Hence, if the sentence submitted is wrong, it will make this response:

isCorrect: bool, isAccomplished: List[bool] = [], wrongWords: List[string] = []

If the sentence is correct, the "wrongWords" list is simply empty. If the sentence is incorrect, the isAccomplished list is simply empty. isAccomplished is basically a list of the objective_id : bool. I don't know what data structure that should be but yeah, it's basically a list of the objective_ids they've sent and whether it's accomplished or not accomplished (true or false).

---- SECOND HTTP REQUEST ---

I think the second type of communication to the backend happens once a level is finished. For example, once the player successfully completed Level 1, we will update their the levels they've cleared already. We have to do this because in the event that a player decides to play in a different device from where they have been originally playing, we still want to get that same info of which levels are already unlocked. Basically, the entire game progress is stored in the database.

My problem is how will I do this? Do you think it's better if I don't use firebase anymore and just stick to the Neon.tech postgres? 

Let's first talk about the stuff I've implied here. We should mainly talk about how the backend architecture will work. We will talk about the adaptive level later.
